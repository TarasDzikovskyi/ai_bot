require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const {OpenAI} = require('openai');
const fs = require('fs');
const path = require('path');
const axios = require('axios');

const ports = [
    { text: '–®–∞–Ω—Ö–∞–π', value: 'Shanghai' },
    { text: '–ù—ñ–Ω–±–æ', value: 'Ningbo' },
    { text: '–°—ñ–Ω–≥–∞–ø—É—Ä', value: 'Singapore' },
    { text: '–ì–æ–Ω–∫–æ–Ω–≥', value: 'HongKong' },
    { text: '–ü—É—Å–∞–Ω', value: 'Busan' },
    { text: '–¢—ñ–∞–Ω—Ü–∑—ñ–Ω—å', value: 'Tianjin' },
    { text: '–ì–∞–º–±—É—Ä–≥', value: 'Hamburg' },
    { text: '–†–æ—Ç—Ç–µ—Ä–¥–∞–º', value: 'Rotterdam' },
    { text: '–ê–Ω—Ç–≤–µ—Ä–ø–µ–Ω', value: 'Antwerp' },
    { text: '–î—É–±–∞–π', value: 'Dubai' },
    { text: '–û–¥–µ—Å–∞', value: 'Odessa' },
];

const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, {polling: true});
const openai = new OpenAI({apiKey: process.env.OPENAI_API_KEY});

const userState = new Map();
const dialogStates = new Map();
const sessionMap = new Map();

bot.onText(/\/start/, (msg) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, '–ü—Ä–∏–≤—ñ—Ç! –û–±–µ—Ä–∏ –¥—ñ—é:', {
        reply_markup: {
            keyboard: [
                ['üîä –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –∞—É–¥—ñ–æ', 'üìù –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ —Ç–µ–∫—Å—Ç'],
                ['üì¶ –ü—Ä–æ—Ä–∞—Ö—É–≤–∞—Ç–∏ –≤–∞–Ω—Ç–∞–∂', '‚ÑπÔ∏è –î–æ–ø–æ–º–æ–≥–∞']
            ],
            resize_keyboard: true,
            one_time_keyboard: false
        }
    });
});


bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    const state = dialogStates.get(chatId);
    const sessionState = sessionMap.get(chatId);
    const user = userState.get(chatId);


    if (user?.isEditing) {
        if (msg.text || msg.voice || msg.audio) {
            await handleCorrection(msg, chatId, user);
            userState.delete(chatId);
            return;
        } else {
            await bot.sendMessage(chatId, '–ù–∞–¥—ñ—à–ª–∏ —Ç–µ–∫—Å—Ç –∞–±–æ –∞—É–¥—ñ–æ –∑ —É—Ç–æ—á–Ω–µ–Ω–Ω—è–º.');
            return;
        }
    }

    console.log(msg);

    try {
        if (sessionState === 'awaiting_gpt_input') {
            sessionMap.delete(chatId);

            if (isLikelyOrder(msg.text)) {
                await handleText(msg.text, chatId);
            } else {
                // await bot.sendMessage(chatId, '–¶–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ —Å—Ö–æ–∂–µ –Ω–∞ –∑–∞–ø–∏—Ç —â–æ–¥–æ –ø–µ—Ä–µ–≤–µ–∑–µ–Ω–Ω—è –≤–∞–Ω—Ç–∞–∂—É. –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∫–∞–∂—ñ—Ç—å –¥–µ—Ç–∞–ª—ñ –¥–æ—Å—Ç–∞–≤–∫–∏.');
            }
        }

        if (sessionState === 'awaiting_gpt_audio') {
            sessionMap.delete(chatId);
            if (msg.voice || msg.audio) {
                await handleAudio(msg, chatId);
            }
            // else await bot.sendMessage(chatId, '–¶–µ –Ω–µ –∞—É–¥—ñ–æ!')
        }

        if (msg.text === 'üîä –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –∞—É–¥—ñ–æ') {
            sessionMap.set(chatId, 'awaiting_gpt_audio');
            await bot.sendMessage(chatId, '–ù–∞–¥—ñ—à–ª–∏ –≥–æ–ª–æ—Å–æ–≤–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—î—é –ø—Ä–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è.');
            return;
        }

        if (msg.text === 'üìù –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ —Ç–µ–∫—Å—Ç') {
            sessionMap.set(chatId, 'awaiting_gpt_input');
            await bot.sendMessage(chatId, '–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å —Ç–µ–∫—Å—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –Ω–∞ –ø—Ä–æ—Ä–∞—Ö—É–Ω–æ–∫ –≤–∞–Ω—Ç–∞–∂—É.');
            return;
        }

        if (msg.text === 'üì¶ –ü—Ä–æ—Ä–∞—Ö—É–≤–∞—Ç–∏ –≤–∞–Ω—Ç–∞–∂') {
            dialogStates.set(chatId, {step: 'awaitingPort'});

            const inlineKeyboard = chunkArray(
                ports.map(p => ({ text: p.text, callback_data: `port:${p.value}` })),
                2
            );

            return bot.sendMessage(chatId, '–û–±–µ—Ä—ñ—Ç—å –ø–æ—Ä—Ç –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:', {
                reply_markup: {
                    inline_keyboard: inlineKeyboard,
                },
            });
        }

        if (state) {
            if (state?.step === 'awaitingCity') {
                state.city = msg.text;
                state.step = 'awaitingVolume';
                return bot.sendMessage(chatId, '–í–≤–µ–¥—ñ—Ç—å –æ–± º—î–º (–º¬≥):');
            }

            // –°—Ü–µ–Ω–∞—Ä—ñ–π –Ω–∞ –≤–≤–µ–¥–µ–Ω–Ω—è –æ–±'—î–º—É
            if (state?.step === 'awaitingVolume') {
                if (isNaN(parseFloat(msg.text))) return bot.sendMessage(chatId, '–í–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–µ —á–∏—Å–ª–æ (–º¬≥):');
                state.volume = parseFloat(msg.text);
                state.step = 'awaitingWeight';
                return bot.sendMessage(chatId, '–í–≤–µ–¥—ñ—Ç—å –≤–∞–≥—É (–∫–≥):');
            }

            if (state?.step === 'awaitingVolume') {
                if (isNaN(parseFloat(msg.text))) return bot.sendMessage(chatId, '–í–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–µ —á–∏—Å–ª–æ (–º¬≥):');
                state.volume = parseFloat(msg.text);
                state.step = 'awaitingWeight';
                return bot.sendMessage(chatId, '–í–≤–µ–¥—ñ—Ç—å –≤–∞–≥—É (–∫–≥):');
            }

            // –°—Ü–µ–Ω–∞—Ä—ñ–π –Ω–∞ –≤–≤–µ–¥–µ–Ω–Ω—è –≤–∞–≥–∏
            if (state?.step === 'awaitingWeight') {
                if (isNaN(parseFloat(msg.text))) return bot.sendMessage(chatId, '–í–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω—É –≤–∞–≥—É (–∫–≥):');
                state.weight = parseFloat(msg.text);
                state.step = 'awaitingConfirmation';

                const summary = `üîç –í–∏ –≤–≤–µ–ª–∏:\n` +
                    `–ü–æ—Ä—Ç: ${state.port}\n` +
                    `–ú—ñ—Å—Ç–æ –¥–æ—Å—Ç–∞–≤–∫–∏: ${state.city}\n` +
                    `–û–± º—î–º: ${state.volume} –º¬≥\n` +
                    `–í–∞–≥–∞: ${state.weight} –∫–≥\n\n` +
                    `–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è?`;

                return bot.sendMessage(chatId, summary, {
                    reply_markup: {
                        inline_keyboard: [
                            [
                                {text: '‚úÖ –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏', callback_data: 'confirm'},
                                {text: '‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', callback_data: 'cancel'}
                            ],
                        ],
                    },
                });
            }
        }

        if (msg.text === '‚ÑπÔ∏è –î–æ–ø–æ–º–æ–≥–∞') {
            await bot.sendMessage(chatId, '–ù–∞–¥—ñ—à–ª–∏ —Ç–µ–∫—Å—Ç –∞–±–æ –≥–æ–ª–æ—Å–æ–≤–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, –∞ –±–æ—Ç –æ–±—Ä–æ–±–∏—Ç—å –≤–∞—à—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é —ñ –ø—Ä–æ—Ä–∞—Ö—É—î —Å—É–º—É –¥–æ—Å—Ç–∞–≤–∫–∏. –Ø–∫—â–æ –∞—É–¥—ñ–æ –¥–∞–Ω—ñ –Ω–µ —Ç–æ—á–Ω—ñ ‚Äî —Ç–∏ –∑–º–æ–∂–µ—à —ó—Ö —É—Ç–æ—á–Ω–∏—Ç–∏.');
            return;
        }

        // if (msg.voice || msg.audio) {
        //     await handleAudio(msg, chatId);
        // }
        // else if (msg.text) {
        //     // await handleText(msg.text, chatId);
        //     // } else if (msg.photo) {
        //     //     await handlePhoto(msg, chatId);
        // } else {
        //     bot.sendMessage(chatId, '–ë—É–¥—å –ª–∞—Å–∫–∞, –Ω–∞–¥—ñ—à–ª–∏ —Ç–µ–∫—Å—Ç –∞–±–æ –∞—É–¥—ñ–æ –¥–ª—è –ø—Ä–æ—Ä–∞—Ö—É–Ω–∫—É —Ü—ñ–Ω–∏.');
        // }
    } catch (error) {
        console.error('‚ùå Error:', error);
        bot.sendMessage(chatId, '–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è.');
    }
});

// üéôÔ∏è –û–±—Ä–æ–±–∫–∞ –∞—É–¥—ñ–æ –∞–±–æ voice
async function handleAudio(msg, chatId) {
    const fileId = msg.voice?.file_id || msg.audio?.file_id;

    const file = await bot.getFile(fileId);
    const fileUrl = `https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${file.file_path}`;

    const processingMsg = await bot.sendMessage(chatId, 'üéß –û–±—Ä–æ–±–ª—è—é –∞—É–¥—ñ–æ...');

    try {
        const localFilePath = await downloadFile(fileUrl, `audio_${Date.now()}.oga`);

        // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ Whisper –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü—ñ—ó
        const transcription = await openai.audio.transcriptions.create({
            file: fs.createReadStream(localFilePath),
            model: "whisper-1",
            language: "uk"
        });

        if (!transcription.text) {
            throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ —Ç–µ–∫—Å—Ç –∑ –∞—É–¥—ñ–æ');
        }

        console.log(transcription);

        const text = transcription.text;

        // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ GPT –¥–ª—è –≤–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –∑ —Ç–µ–∫—Å—Ç—É
        const prompt = getPrompt(text);


        const gptResponse = await openai.chat.completions.create({
            model: 'gpt-3.5-turbo',
            messages: [{role: 'user', content: prompt}]
        });

        console.log(gptResponse);


        const reply = gptResponse.choices[0].message.content;
        console.log(reply)

        let parsed;
        try {
            parsed = JSON.parse(reply);
        } catch (err) {
            console.error('‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø–∞—Ä—Å–∏—Ç–∏ JSON:', err);
            await bot.editMessageText('–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ GPT.', {
                chat_id: chatId,
                message_id: processingMsg.message_id
            });
            return;
        }

        if (!parsed.from.confidence || !parsed.to.confidence || !parsed.weight.confidence || !parsed.volume.confidence) {
            userState.set(chatId, {
                originalText: text,
                originalData: parsed,
                isEditing: true,
                sourceType: 'audio'
            });

            await bot.sendMessage(chatId, '–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –¥–∞–Ω—ñ –∑ –∞—É–¥—ñ–æ. –ó–º—ñ–Ω–∏—Ç–∏?', {
                reply_markup: {
                    inline_keyboard: [
                        [{text: '–¢–∞–∫', callback_data: 'edit_yes'}, {text: '–ù—ñ', callback_data: 'edit_no'}]
                    ]
                }
            });
        } else {
            // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–≤—ñ
            await bot.editMessageText(reply, {
                chat_id: chatId,
                message_id: processingMsg.message_id
            });
        }
    } catch (error) {
        console.error('‚ùå Error in audio processing:', error);
        await bot.editMessageText('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –∞—É–¥—ñ–æ. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.', {
            chat_id: chatId,
            message_id: processingMsg.message_id
        });
    }
}

// üí¨ –û–±—Ä–æ–±–∫–∞ —Ç–µ–∫—Å—Ç—É
async function handleText(text, chatId) {
    const prompt = getPrompt(text);

    const gptResponse = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [{role: 'user', content: prompt}]
    });

    const reply = gptResponse.choices[0].message.content;
    await bot.sendMessage(chatId, reply);
}

// üñºÔ∏è –û–±—Ä–æ–±–∫–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
async function handlePhoto(msg, chatId) {
    const fileId = msg.photo[msg.photo.length - 1].file_id; // –ù–∞–π–±—ñ–ª—å—à–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    const file = await bot.getFile(fileId);
    const fileUrl = `https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${file.file_path}`;

    const processingMsg = await bot.sendMessage(chatId, 'üß† –ê–Ω–∞–ª—ñ–∑—É—é –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è...');

    const visionResponse = await openai.chat.completions.create({
        model: "gpt-4-vision-preview",
        messages: [
            {
                role: "user",
                content: [
                    {type: "text", content: "–ü—Ä–æ–∞–Ω–∞–ª—ñ–∑—É–π —Ü–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∞–±–æ –≤–∏—Ç—è–≥–Ω–∏ –¥–∞–Ω—ñ –∑ –Ω—å–æ–≥–æ."},
                    {type: "image_url", image_url: {url: fileUrl}}
                ]
            }
        ]
    });

    const reply = visionResponse.choices[0].message.content;
    await bot.editMessageText(reply, {
        chat_id: chatId,
        message_id: processingMsg.message_id
    });
}


bot.on('callback_query', async (query) => {
    const chatId = query.message.chat.id;
    const user = userState.get(chatId);
    const state = dialogStates.get(chatId);

    if (query.data.startsWith('port:')) {
        const port = query.data.split(':')[1];
        if (state) {
            state.port = port;
            state.step = 'awaitingCity';
            return bot.sendMessage(chatId, '–í–≤–µ–¥—ñ—Ç—å –º—ñ—Å—Ç–æ –¥–æ—Å—Ç–∞–≤–∫–∏:');
        }
    }

    if (query.data === 'edit_yes') {
        await bot.sendMessage(chatId, '–ë—É–¥—å –ª–∞—Å–∫–∞, –Ω–∞–¥—ñ—à–ª–∏ –Ω–æ–≤–µ –∞—É–¥—ñ–æ –∞–±–æ —Ç–µ–∫—Å—Ç —ñ–∑ —É—Ç–æ—á–Ω–µ–Ω–Ω—è–º–∏.');
    }

    if (query.data === 'edit_no') {
        userState.delete(chatId);
        await bot.sendMessage(chatId, '–î–æ–±—Ä–µ, –æ–±—Ä–æ–±–∫—É —Å–∫–∞—Å–æ–≤–∞–Ω–æ.');
    }

    if (query.data === 'confirm_correct') {
        // –¢—É—Ç –º–æ–∂–Ω–∞ –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –¥–∞–Ω—ñ –≤ 1–° ‚Äî –ø–æ–∫–∏ –∑–∞–≥–ª—É—à–∫–∞
        console.log('‚û°Ô∏è –ù–∞–¥—Å–∏–ª–∞—î–º–æ –≤ 1–°:', user?.correctedData || user?.originalData);

        await bot.sendMessage(chatId, '‚úÖ –î–∞–Ω—ñ –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ –¥–æ 1–°! –î—è–∫—É—é.');
        userState.delete(chatId); // –û—á–∏—Å—Ç–∏—Ç–∏ —Å—Ç–∞–Ω
    }

    if (query.data === 'cancel_all') {
        await bot.sendMessage(chatId, '‚ùå –£—Ç–æ—á–Ω–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ. –Ø–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ, –Ω–∞–¥—ñ—à–ª–∏ –Ω–æ–≤—ñ –¥–∞–Ω—ñ.');
        userState.delete(chatId);
    }


    if (query.data === 'confirm') {
        if (state?.step === 'awaitingConfirmation') {
            // –¢—É—Ç –±—É–¥–µ –∑–∞–ø–∏—Ç –¥–æ 1–° –∞–±–æ —ñ–Ω—à–∞ –ª–æ–≥—ñ–∫–∞
            await bot.sendMessage(chatId, 'üöÄ –î–∞–Ω—ñ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ –ø—Ä–æ—Ä–∞—Ö—É–Ω–æ–∫ –¥–æ 1–°.\n–û—á—ñ–∫—É–π—Ç–µ –≤—ñ–¥–ø–æ–≤—ñ–¥—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞.');
            dialogStates.delete(chatId); // –û—á–∏—Å—Ç–∏—Ç–∏ —Å—Ç–∞–Ω
        }
    }

    // –°–∫–∞—Å—É–≤–∞–Ω–Ω—è
    if (query.data === 'cancel') {
        dialogStates.delete(chatId);
        await bot.sendMessage(chatId, '‚ùå –ü—Ä–æ—Ä–∞—Ö—É–Ω–æ–∫ —Å–∫–∞—Å–æ–≤–∞–Ω–æ.');
    }


    await bot.answerCallbackQuery(query.id);
});

console.log('ü§ñ Bot is running...');


function getPrompt(text) {

    const prompt = `
–¢–∏ ‚Äî –¥–æ—Å–≤—ñ–¥—á–µ–Ω–∏–π –ª–æ–≥—ñ—Å—Ç–∏—á–Ω–∏–π –∞—Å–∏—Å—Ç–µ–Ω—Ç. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî —É–≤–∞–∂–Ω–æ –ø—Ä–æ–∞–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —Ç–µ–∫—Å—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –Ω–∞ –ø–µ—Ä–µ–≤–µ–∑–µ–Ω–Ω—è –≤–∞–Ω—Ç–∞–∂—É —Ç–∞ –≤–∏—Ç—è–≥–Ω—É—Ç–∏ –∑ –Ω—å–æ–≥–æ –∫–ª—é—á–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –º–∞—Ä—à—Ä—É—Ç —ñ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –≤–∞–Ω—Ç–∞–∂—É.

üîç –ù–∞–π–≤–∞–∂–ª–∏–≤—ñ—à–µ:
- –û–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ –ø–µ—Ä–µ–≤—ñ—Ä, —á–∏ –≤–∫–∞–∑–∞–Ω–∏–π –ø–æ—Ä—Ç —É –ø–æ–ª—ñ "from" —î —Ä–µ–∞–ª—å–Ω–∏–º, –º—ñ–∂–Ω–∞—Ä–æ–¥–Ω–æ –≤–∏–∑–Ω–∞–Ω–∏–º –ø–æ—Ä—Ç–æ–º (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, —á–µ—Ä–µ–∑ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö –ø–æ—Ä—Ç—ñ–≤).
- –Ø–∫—â–æ —Ç–∞–∫–æ–≥–æ –ø–æ—Ä—Ç—É **–Ω–µ —ñ—Å–Ω—É—î**, –∞–±–æ –Ω–∞–∑–≤–∞ –Ω–∞–ø–∏—Å–∞–Ω–∞ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ, –∞–±–æ –Ω–µ –≤–∫–∞–∑–∞–Ω–∏–π —Å–∞–º–µ –ø–æ—Ä—Ç (–∞ –Ω–µ –ø—Ä–æ—Å—Ç–æ –º—ñ—Å—Ç–æ) ‚Äî –ø–æ–≤–µ—Ä–Ω–∏ **null**: 'null'. –¶–µ –æ–±–æ–≤ º—è–∑–∫–æ–≤–∞ —É–º–æ–≤–∞.
- –¢–∞–∫ —Å–∞–º–æ –æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ –ø–µ—Ä–µ–≤—ñ—Ä, —á–∏ –≤–∫–∞–∑–∞–Ω–µ –º—ñ—Å—Ü–µ –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è –≤ –ø–æ–ª—ñ "to" (–º—ñ—Å—Ç–æ –∞–±–æ –∫—Ä–∞—ó–Ω–∞) **–¥—ñ–π—Å–Ω–æ —ñ—Å–Ω—É—î**. –Ø–∫—â–æ –≤–æ–Ω–æ –Ω–µ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫—É—î—Ç—å—Å—è ‚Äî —Ç–∞–∫–æ–∂ –ø–æ–≤–µ—Ä–Ω–∏ **null** 'null'.

üì¶ –ù–∞ –æ—Å–Ω–æ–≤—ñ –Ω–∞–¥–∞–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç—É –ø–æ–≤–µ—Ä–Ω–∏ **—Ç—ñ–ª—å–∫–∏** –≤–∞–ª—ñ–¥–Ω–∏–π JSON –∑ –Ω–∞—Å—Ç—É–ø–Ω–æ—é —Å—Ç—Ä—É–∫—Ç—É—Ä–æ—é:

{
  "from": {
    "value": "–ú—ñ–∂–Ω–∞—Ä–æ–¥–Ω–∞ –Ω–∞–∑–≤–∞ –ø–æ—Ä—Ç—É –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è (–∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—é, –ª–∏—à–µ –ø–æ—Ä—Ç)",
    "confidence": true | false
  },
  "to": {
    "value": "–ú—ñ—Å—Ü–µ —Ä–æ–∑–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∞–±–æ –¥–æ—Å—Ç–∞–≤–∫–∏ (–∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—é)",
    "confidence": true | false
  },
  "weight": {
    "value": "–í–∞–≥–∞ –≤–∞–Ω—Ç–∞–∂—É —É –∫—ñ–ª–æ–≥—Ä–∞–º–∞—Ö (—Ç—ñ–ª—å–∫–∏ —á–∏—Å–ª–æ –∞–±–æ null)",
    "confidence": true | false
  },
  "volume": {
    "value": "–û–± º—î–º –≤–∞–Ω—Ç–∞–∂—É —É –∫—É–±—ñ—á–Ω–∏—Ö –º–µ—Ç—Ä–∞—Ö (—Ç—ñ–ª—å–∫–∏ —á–∏—Å–ª–æ –∞–±–æ null)",
    "confidence": true | false
  }
}

üìå –î–æ–¥–∞—Ç–∫–æ–≤—ñ —É–º–æ–≤–∏:
- –Ø–∫—â–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –Ω–µ –∑–≥–∞–¥—É—î—Ç—å—Å—è –∞–±–æ –Ω–µ—á—ñ—Ç–∫–∞ ‚Äî –≤–∫–∞–∂–∏ "value": null —ñ "confidence": false.
- –Ø–∫—â–æ –æ–¥–∏–Ω–∏—Ü—ñ —ñ–Ω—à—ñ (—Ç–æ–Ω–Ω–∏, –ª—ñ—Ç—Ä–∏, —Ñ—É—Ç¬≥ —Ç–æ—â–æ) ‚Äî –∫–æ–Ω–≤–µ—Ä—Ç—É–π —É –∫–≥ –∞–±–æ –º¬≥.
- –ü–æ–∑–Ω–∞—á–∞–π "confidence": true —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –≤–ø–µ–≤–Ω–µ–Ω–∏–π –Ω–∞ 100%.
- **–ù—ñ–∫–æ–ª–∏** –Ω–µ –¥–æ–¥–∞–≤–∞–π –∂–æ–¥–Ω–∏—Ö –ø–æ—è—Å–Ω–µ–Ω—å ‚Äî –ª–∏—à–µ JSON –∞–±–æ –ø–æ—Ä–æ–∂–Ω—ñ–π –æ–±'—î–∫—Ç.
- –Ø–∫—â–æ –ø–æ—Ä—Ç "from" –∞–±–æ –º—ñ—Å—Ü–µ "to" –Ω–µ –≤–∞–ª—ñ–¥–Ω–µ –∞–±–æ –Ω–µ —ñ—Å–Ω—É—î ‚Äî **–≤—ñ–¥–ø–æ–≤—ñ–¥—å –º–∞—î –±—É—Ç–∏ —Ç—ñ–ª—å–∫–∏** 'null'.

–û—Å—å —Ç–µ–∫—Å—Ç:
"""${text}"""
`;


    return prompt;
}


async function downloadFile(url, filename) {

    const directoryPath = path.join(__dirname, 'audio');

    await fs.promises.mkdir(directoryPath, {recursive: true});

    const filePath = path.join(directoryPath, filename);

    const writer = fs.createWriteStream(filePath);

    const response = await axios.get(url, {responseType: 'stream'});
    response.data.pipe(writer);

    return new Promise((resolve, reject) => {
        writer.on('finish', () => resolve(filePath));
        writer.on('error', reject);
    });
}


function createResponseText() {
    const text = `üîç –í–∞—à—ñ –¥–∞–Ω—ñ:
    –ü–æ—Ä—Ç –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: 
    –ú—ñ—Å—Ü–µ –¥–æ—Å—Ç–∞–≤–∫–∏:
    –í–∞–≥–∞ –≤–∞–Ω—Ç–∞–∂—É:
    –û–± º—î–º –≤–∞–Ω—Ç–∞–∂—É:
    
    –ù–∞ –æ—Å–Ω–æ–≤—ñ –≤–∞—à–∏—Ö –¥–∞–Ω–∏—Ö –±—É–ª–æ –ø—Ä–æ—Ä–∞—Ö–æ–≤–∞–Ω–æ –Ω–∞—Å—Ç—É–ø–Ω–µ: 
    –¶—ñ–Ω–∞ –¥–æ –º—ñ—Å—Ü—è –¥–æ—Å—Ç–∞–≤–∫–∏:
    –¶—ñ–Ω–∞ –¥–æ –¥–≤–µ—Ä–µ–π: `

    return text
}


async function handleCorrection(msg, chatId, user) {
    let newText = '';

    if (msg.text) {
        newText = msg.text;
    } else if (msg.voice || msg.audio) {
        const fileId = msg.voice?.file_id || msg.audio?.file_id;
        const file = await bot.getFile(fileId);
        const fileUrl = `https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${file.file_path}`;
        const localFilePath = await downloadFile(fileUrl, `correction_${Date.now()}.oga`);

        const transcription = await openai.audio.transcriptions.create({
            file: fs.createReadStream(localFilePath),
            model: "whisper-1",
            language: "uk"
        });

        newText = transcription.text;
    }

    console.log(user)

    const combinedPrompt = `
–Ñ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π –æ–±'—î–∫—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –∑ –¥–µ—è–∫–∏–º–∏ –Ω–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏–º–∏ –¥–∞–Ω–∏–º–∏ (confidence: false):
"""${user.originalData}"""

–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á —É—Ç–æ—á–Ω–∏–≤ –Ω–∞—Å—Ç—É–ø–Ω–µ:
"""${newText}"""

–ù–∞ –æ—Å–Ω–æ–≤—ñ –æ–±–æ—Ö —á–∞—Å—Ç–∏–Ω –æ–Ω–æ–≤–∏ –æ–± º—î–∫—Ç –¥–∞–Ω–∏—Ö —Ç–∞ –ø–æ–≤–µ—Ä–Ω–∏ –æ–Ω–æ–≤–ª–µ–Ω–∏–π –æ–±'—î–∫—Ç (–¥–∏–≤–∏—Å—å –ø—Ä–∞–≤–∏–ª–∞ —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è).
`;

    console.log(combinedPrompt)

    const gptResponse = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [{role: 'user', content: combinedPrompt}]
    });

    const reply = gptResponse.choices[0].message.content;

    user.correctedData = reply;
    userState.set(chatId, user);

    await bot.sendMessage(chatId, `–û–Ω–æ–≤–ª–µ–Ω—ñ –¥–∞–Ω—ñ:\n${reply}`, {
        reply_markup: {
            inline_keyboard: [
                [
                    {text: '‚úÖ –í—Å–µ –≤—ñ—Ä–Ω–æ', callback_data: 'confirm_correct'},
                    {text: '‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', callback_data: 'cancel_all'}
                ]
            ]
        }
    });
}


function isLikelyOrder(text) {
    const keywords = [
        '–¥–æ—Å—Ç–∞–≤–∫–∞', '–ø–æ—Ä—Ç', '–º–æ—Ä–µ', '–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä',
        '–≤—ñ–¥–ø—Ä–∞–≤–∫–∞', '–æ–± º—î–º', '–≤–∞–≥–∞', '–º¬≥', '–∫–≥', '–º—ñ—Å—Ç–æ',
        'to', 'from', 'shipment', 'cargo', 'volume', 'weight', 'city'
    ];

    const lowerText = text.toLowerCase();

    return keywords.some(word => lowerText.includes(word));
}



function chunkArray(array, size) {
    const chunked = [];
    for (let i = 0; i < array.length; i += size) {
        chunked.push(array.slice(i, i + size));
    }
    return chunked;
}